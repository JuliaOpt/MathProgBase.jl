<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>High-level Interfaces · MathProgBase</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathProgBase</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="apimanual.html">Solver Interface Manual</a></li><li><a class="toctext" href="apireference.html">Solver Interface API</a></li><li class="current"><a class="toctext" href="highlevel.html">High-level Interfaces</a><ul class="internal"><li><a class="toctext" href="#Linear-Programming-1">Linear Programming</a></li><li><a class="toctext" href="#Mixed-integer-Programming-1">Mixed-integer Programming</a></li><li><a class="toctext" href="#Quadratic-Programming-1">Quadratic Programming</a></li></ul></li><li><a class="toctext" href="choosingsolver.html">Choosing Solvers</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="highlevel.html">High-level Interfaces</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/699698f0da7e6626de5c90f5ce291a8b7f8c2cde/docs/src/highlevel.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>High-level Interfaces</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="High-level-Interfaces-1" href="#High-level-Interfaces-1">High-level Interfaces</a></h1><p><strong>These docs are out of date. We need to update the high-level interfaces for new statuses.</strong></p><h2><a class="nav-anchor" id="Linear-Programming-1" href="#Linear-Programming-1">Linear Programming</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.linprog" href="#MathProgBase.linprog"><code>MathProgBase.linprog</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linprog(c::InputVector, A::AbstractMatrix, rowlb::InputVector, rowub::InputVector, lb::InputVector, ub::InputVector, solver::AbstractMathProgSolver)</code></pre><p>This function allows one to specify two-sided linear constraints (also known as range constraints) to solve the linear programming problem:</p><div>\[\begin{align*}
\text{min}_{x} \quad &amp; c^{T} x \\
\text{s.t.}    \quad &amp; rowlb \leq A^{T} x \leq rowub \\
                \quad &amp; l \leq x \leq u \\

\end{align*}\]</div><p>where:</p><ul><li><p><span>$c$</span> is the objective vector, always in the sense of minimization</p></li><li><p><span>$A$</span> is the constraint matrix</p></li><li><p><span>$rowlb$</span> is the vector of row lower bounds</p></li><li><p><span>$rowub$</span> is the vector of row upper bounds</p></li><li><p><span>$lb$</span> is the vector of lower bounds on the variables</p></li><li><p><span>$ub$</span> is the vector of upper bounds on the variables, and</p></li><li><p><span>$solver$</span> specifies the desired solver, see <a href="choosingsolver.html#Choosing-Solvers-1">Choosing Solvers</a>.</p></li></ul><p>A scalar is accepted for the <span>$l$</span>, <span>$u$</span>, <span>$rowlb$</span>, and <span>$rowub$</span> arguments, in which case its value is replicated. The values <span>$-Inf$</span> and <span>$Inf$</span> are interpreted to mean that there is no corresponding lower or upper bound. Equality constraints are specified by setting the row lower and upper bounds to the same value.</p><p>A variant usage of this function is to consider the linear programming problem in the following form,</p><pre><code class="language-julia">linprog(c::InputVector, A::AbstractMatrix, sense::InputVector, b::InputVector, lb::InputVector, ub::InputVector, solver::AbstractMathProgSolver)</code></pre><div>\[\begin{align*}
\text{min}_{x} \quad &amp; c^{T}x \\
\text{s.t.}    \quad &amp; A_{i}^{T} \, \text{sense}_{i} \, b_{i} \quad \forall i \\
                \quad &amp; l \leq x \leq u
\end{align*}\]</div><p>where:</p><ul><li><p><span>$c$</span>: is the objective vector, always in the sense of minimization</p></li><li><p><span>$A$</span>: is the constraint matrix, with rows a_i (viewed as column-oriented vectors)</p></li><li><p>sense: is a vector of constraint sense characters <span>$&lt;$</span>, <span>$=$</span>, and <span>$&gt;$</span></p></li><li><p><span>$b$</span>: is the right-hand side vector</p></li><li><p><span>$l$</span>: is the vector of lower bounds on the variables</p></li><li><p><span>$u$</span> is the vector of upper bounds on the variables, and solver specifies the desired solver, see <a href="choosingsolver.html#Choosing-Solvers-1">Choosing Solvers</a>.</p></li></ul><p>A shortened version is defined as::</p><pre><code class="language-julia">linprog(c, A, lb, ub, solver) = linprog(c, A, lb, ub, 0, Inf, solver)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The function <a href="highlevel.html#MathProgBase.linprog"><code>linprog</code></a> calls two independent functions for building and solving the linear programming problem, namely <a href="highlevel.html#MathProgBase.buildlp"><code>buildlp</code></a> and <a href="highlevel.html#MathProgBase.solvelp"><code>solvelp</code></a>.</p></div></div><p>The <a href="highlevel.html#MathProgBase.linprog"><code>linprog</code></a> function returns an instance of the type::</p><pre><code class="language-julia">type LinprogSolution
    status
    objval
    sol
    attrs
end</code></pre><p>where <code>status</code> is a termination status symbol, one of <code>:Optimal</code>, <code>:Infeasible</code>, <code>:Unbounded</code>, <code>:UserLimit</code> (iteration limit or timeout), <code>:Error</code> (and maybe others).</p><p>If <code>status</code> is <code>:Optimal</code>, the other members have the following values:</p><ul><li><p><code>objval</code> – optimal objective value</p></li><li><p><code>sol</code> – primal solution vector</p></li><li><p><code>attrs</code> – a dictionary that may contain other relevant attributes such as:</p><ul><li><p><code>redcost</code> – dual multipliers for active variable bounds (zero if inactive)</p></li><li><p><code>lambda</code> – dual multipliers for active linear constraints (equalities are always active)</p></li></ul></li></ul><p>If <code>status</code> is <code>:Infeasible</code>, the <code>attrs</code> member will contain an <code>infeasibilityray</code> if available; similarly for <code>:Unbounded</code> problems, <code>attrs</code> will contain an <code>unboundedray</code> if available.</p><ul><li><p><code>colbasis</code> – optimal simplex basis statuses for the variables (columns) if available. Possible values are <code>:NonbasicAtLower</code>, <code>:NonbasicAtUpper</code>, <code>:Basic</code>, and <code>:Superbasic</code> (not yet implemented by any solvers)</p></li><li><p><code>rowbasis</code> – optimal simplex basis statuses for the constraints (rows) if available (not yet implemented by any solvers)</p></li></ul><p>For example, we can solve the two-dimensional problem (see <code>test/linprog.jl</code>):</p><div>\[    \begin{align*}
    \text{min}_{x,y} \quad &amp; -x \\
    \text{s.t.}      \quad &amp; 2x + y \leq 1.5 \\
                      \quad &amp; x \geq 0, y \geq 0
    \end{align*}\]</div><pre><code class="language-julia">using MathProgBase, Clp

sol = linprog([-1,0],[2 1],&#39;&lt;&#39;,1.5, ClpSolver())
if sol.status == :Optimal
    println(&quot;Optimal objective value is $(sol.objval)&quot;)
    println(&quot;Optimal solution vector is: [$(sol.sol[1]), $(sol.sol[2])]&quot;)
else
    println(&quot;Error: solution status $(sol.status)&quot;)
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/699698f0da7e6626de5c90f5ce291a8b7f8c2cde/src/HighLevelInterface/linprog.jl#L165-L285">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.buildlp" href="#MathProgBase.buildlp"><code>MathProgBase.buildlp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">buildlp(c::InputVector, A::AbstractMatrix, sense::InputVector, b::InputVector, lb::InputVector, ub::InputVector, solver::AbstractMathProgSolver)</code></pre><p>Builds the linear programming problem as defined in <a href="highlevel.html#MathProgBase.linprog"><code>linprog</code></a> and accepts the following arguments:</p><ul><li><p><span>$c$</span> is the objective vector, always in the sense of minimization</p></li><li><p><span>$A$</span> is the constraint matrix</p></li><li><p><span>$sense$</span> is a vector of constraint sense characters <span>$&#39;&lt;&#39;$</span>, <span>$&#39;=&#39;$</span>, and <span>$&#39;&gt;&#39;$</span></p></li><li><p><span>$b$</span> is the right-hand side vector</p></li><li><p><span>$l$</span> is the vector of lower bounds on the variables</p></li><li><p><span>$u$</span> is the vector of upper bounds on the variables, and</p></li><li><p><span>$solver$</span> specifies the desired solver, see <a href="choosingsolver.html#Choosing-Solvers-1">Choosing Solvers</a>.</p></li></ul><p>A scalar is accepted for the <span>$b$</span>, <span>$sense$</span>, <span>$l$</span>, and <span>$u$</span> arguments, in which case its value is replicated. The values <span>$-Inf$</span> and <span>$Inf$</span> are interpreted to mean that there is no corresponding lower or upper bound.</p><p>This variant of <a href="highlevel.html#MathProgBase.buildlp"><code>buildlp</code></a> allows to specify two-sided linear constraints (also known as range constraints) similar to <a href="highlevel.html#MathProgBase.linprog"><code>linprog</code></a>, and accepts the following arguments:</p><pre><code class="language-none">buildlp(c::InputVector, A::AbstractMatrix, rowlb::InputVector, rowub::InputVector, lb::InputVector, ub::InputVector, solver::AbstractMathProgSolver)</code></pre><ul><li><p><span>$c$</span> is the objective vector, always in the sense of minimization</p></li><li><p><span>$A$</span> is the constraint matrix</p></li><li><p><span>$rowlb$</span> is the vector of row lower bounds</p></li><li><p><span>$rowub$</span> is the vector of row upper bounds</p></li><li><p><span>$lb$</span> is the vector of lower bounds on the variables</p></li><li><p><span>$ub$</span> is the vector of upper bounds on the variables, and</p></li><li><p><span>$solver$</span> specifies the desired solver, see <a href="choosingsolver.html#Choosing-Solvers-1">Choosing Solvers</a>.</p></li></ul><p>A scalar is accepted for the <span>$l$</span>, <span>$u$</span>, <span>$lb$</span>, and <span>$ub$</span> arguments, in which case its value is replicated. The values <span>$-Inf$</span> and <span>$Inf$</span> are interpreted to mean that there is no corresponding lower or upper bound. Equality constraints are specified by setting the row lower and upper bounds to the same value.</p><p>The <a href="highlevel.html#MathProgBase.buildlp"><code>buildlp</code></a> function returns an <a href="@ref"><code>AbstractLinearQuadraticModel</code></a> that can be input to <a href="highlevel.html#MathProgBase.solvelp"><code>solvelp</code></a> in order to obtain a solution.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/699698f0da7e6626de5c90f5ce291a8b7f8c2cde/src/HighLevelInterface/linprog.jl#L32-L74">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.solvelp" href="#MathProgBase.solvelp"><code>MathProgBase.solvelp</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Solves the linear programming problem as defined in <a href="highlevel.html#MathProgBase.linprog"><code>linprog</code></a> and accepts the following argument:</p><ul><li><p><code>m</code> is an <a href="@ref"><code>AbstractLinearQuadraticModel</code></a> (e.g., as returned by <a href="highlevel.html#MathProgBase.buildlp"><code>buildlp</code></a>).</p></li></ul><p>The <a href="highlevel.html#MathProgBase.solvelp"><code>solvelp</code></a> function returns an instance of the type::</p><pre><code class="language-julia">type LinprogSolution
    status
    objval
    sol
    attrs
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/699698f0da7e6626de5c90f5ce291a8b7f8c2cde/src/HighLevelInterface/linprog.jl#L120-L136">source</a><br/></section><h2><a class="nav-anchor" id="Mixed-integer-Programming-1" href="#Mixed-integer-Programming-1">Mixed-integer Programming</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.mixintprog" href="#MathProgBase.mixintprog"><code>MathProgBase.mixintprog</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mixintprog(c::InputVector, A::AbstractMatrix, sense::InputVector, b::InputVector, vartypes::SymbolInputVector, lb::InputVector, ub::InputVector, solver::AbstractMathProgSolver)</code></pre><p>Solves the same optimization problem as <a href="highlevel.html#MathProgBase.linprog"><code>linprog</code></a> above, except variables are additionally constrained to take only integer values if the corresponding entry in the <code>varypes</code> vector is the symbol <code>:Int</code>. Continuous variables are indicated by the value <code>:Cont</code>, binary variables should be specified by <code>:Bin</code>, semicontinuous by <code>:SemiCont</code>, and semi-integer by <code>:SemiInt</code>.</p><p>A scalar is accepted for the <span>$sense$</span>, <span>$b$</span>, <span>$vartypes$</span>, <span>$lb$</span>, and <span>$ub$</span> arguments, in which case its value is replicated. The values <span>$-Inf$</span> and <span>$Inf$</span> are interpreted to mean that there is no corresponding lower or upper bound.</p><p>The <a href="highlevel.html#MathProgBase.mixintprog"><code>mixintprog</code></a> function returns an instance of the type::</p><pre><code class="language-julia">type MixintprogSolution
    status
    objval
    sol
    attrs
end</code></pre><p>where <code>status</code> takes the same values as with <a href="highlevel.html#MathProgBase.linprog"><code>linprog</code></a>.</p><p>If <code>status</code> does not indicate error or infeasiblity, the other members have the following values:</p><ul><li><p><code>objval</code> – optimal objective value</p></li><li><p><code>sol</code> – primal solution vector</p></li><li><p><code>attrs</code> – a dictionary that may contain other relevant attributes such as:</p><ul><li><p><code>objbound</code> – Best known lower bound on the objective value</p></li></ul></li></ul><p>Analogous shortened and range-constraint versions are available as well.</p><p>We can solve a <a href="http://en.wikipedia.org/wiki/Knapsack_problem">binary knapsack problem</a></p><div>\[\begin{align*}
    \text{max} \, &amp; 5x_1 + 3x_2 + 2x_3 + 7x_4 + 4x_5 \\
    \text{s.t.}    &amp; 2x_1 + 8x_2 + 4x_3 + 2x_4 + 5x_5 \leq 10 \\
                    &amp; (x_1, x_2, x_3, x_4, x_5) \in \{0,1\}^5
\end{align*}\]</div><p>with the following code</p><pre><code class="language-julia">mixintprog(-[5.,3.,2.,7.,4.],[2. 8. 4. 2. 5.],&#39;&lt;&#39;,10,:Int,0,1,CbcSolver())</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/699698f0da7e6626de5c90f5ce291a8b7f8c2cde/src/HighLevelInterface/mixintprog.jl#L22-L69">source</a><br/></section><h2><a class="nav-anchor" id="Quadratic-Programming-1" href="#Quadratic-Programming-1">Quadratic Programming</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.quadprog" href="#MathProgBase.quadprog"><code>MathProgBase.quadprog</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">quadprog(c::InputVector, Q::AbstractMatrix, A::AbstractMatrix, sense::InputVector, b::InputVector, lb::InputVector, ub::InputVector, solver::AbstractMathProgSolver)</code></pre><p>Solves the quadratic programming problem:</p><div>\[    \begin{align*}
    \text{min}_{x} \quad &amp; \frac{1}{2}x^TQx + c^Tx \\
    \text{s.t.}    \quad &amp; a_i^Tx \, \text{sense}_i \, b_i \forall \quad i \\
                    \quad &amp; l \leq x \leq u \\
    \end{align*}\]</div><p>where:</p><ul><li><p><span>$c$</span> is the objective vector, always in the sense of minimization</p></li><li><p><span>$Q$</span> is the Hessian matrix of the objective</p></li><li><p><span>$A$</span> is the constraint matrix, with rows :math:<code>a_i</code> (viewed as column-oriented vectors)</p></li><li><p><span>$sense$</span> is a vector of constraint sense characters <span>$&lt;$</span>, <span>$=$</span>, and <span>$&gt;$</span></p></li><li><p><span>$b$</span> is the right-hand side vector</p></li><li><p><span>$l$</span> is the vector of lower bounds on the variables</p></li><li><p><span>$u$</span> is the vector of upper bounds on the variables, and</p></li><li><p><span>$solver$</span> specifies the desired solver, see <a href="choosingsolver.html#Choosing-Solvers-1">Choosing Solvers</a>.</p></li></ul><p>A scalar is accepted for the <span>$b$</span>, <span>$sense$</span>, <span>$l$</span>, and <span>$u$</span> arguments, in which case its value is replicated. The values <span>$-Inf$</span> and <span>$Inf$</span> are interpreted to mean that there is no corresponding lower or upper bound.</p><p>.. note::     Quadratic programming solvers extensively exploit the sparsity of the Hessian matrix <span>$Q$</span> and the constraint matrix <span>$A$</span>. While both dense and sparse matrices are accepted, for large-scale problems sparse matrices should be provided if permitted by the problem structure.</p><p>The <a href="highlevel.html#MathProgBase.quadprog"><code>quadprog</code></a> function returns an instance of the type::</p><pre><code class="language-julia">type QuadprogSolution
    status
    objval
    sol
    attrs
end</code></pre><p>where <code>status</code> is a termination status symbol, one of <code>:Optimal</code>, <code>:Infeasible</code>, <code>:Unbounded</code>, <code>:UserLimit</code> (iteration limit or timeout), <code>:Error</code> (and maybe others).</p><p>If <code>status</code> is <code>:Optimal</code>, the other members have the following values:</p><ul><li><p><code>objval</code> – optimal objective value</p></li><li><p><code>sol</code> – primal solution vector</p></li><li><p><code>attrs</code> – a dictionary that may contain other relevant attributes (not currently used).</p></li></ul><p>Analogous shortened and range-constraint versions are available as well.</p><p>We can solve the three-dimensional QP (see <code>test/quadprog.jl</code>):</p><div>\[    \begin{align*}
    \text{min}_{x,y,z} \quad &amp; x^2+y^2+z^2+xy+yz \\
    \text{s.t.}        \quad &amp; x + 2y + 3z \geq 4 \\
                        \quad &amp; x + y \geq 1
    \end{align*}\]</div><pre><code class="language-julia">using MathProgBase, Ipopt

sol = quadprog([0., 0., 0.],[2. 1. 0.; 1. 2. 1.; 0. 1. 2.],[1. 2. 3.; 1. 1. 0.],&#39;&gt;&#39;,[4., 1.],-Inf,Inf, IpoptSolver())
if sol.status == :Optimal
    println(&quot;Optimal objective value is $(sol.objval)&quot;)
    println(&quot;Optimal solution vector is: [$(sol.sol[1]), $(sol.sol[2]), $(sol.sol[3])]&quot;)
else
    println(&quot;Error: solution status $(sol.status)&quot;)
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/699698f0da7e6626de5c90f5ce291a8b7f8c2cde/src/HighLevelInterface/quadprog.jl#L20-L100">source</a><br/></section><footer><hr/><a class="previous" href="apireference.html"><span class="direction">Previous</span><span class="title">Solver Interface API</span></a><a class="next" href="choosingsolver.html"><span class="direction">Next</span><span class="title">Choosing Solvers</span></a></footer></article></body></html>
