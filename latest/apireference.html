<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver Interface API · MathProgBase</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathProgBase</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="apireference.html">Solver Interface API</a><ul class="internal"><li><a class="toctext" href="#Variables-1">Variables</a></li><li><a class="toctext" href="#Objectives-1">Objectives</a></li><li><a class="toctext" href="#Constraints-1">Constraints</a></li><li><a class="toctext" href="#Sets-1">Sets</a></li><li><a class="toctext" href="#Attributes-1">Attributes</a></li><li><a class="toctext" href="#Status-Codes-1">Status Codes</a></li><li><a class="toctext" href="#Duals-1">Duals</a></li><li><a class="toctext" href="#Nonlinear-Programming-(NLP)-1">Nonlinear Programming (NLP)</a></li></ul></li><li><a class="toctext" href="highlevel.html">High-level Interfaces</a></li><li><a class="toctext" href="choosingsolver.html">Choosing Solvers</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="apireference.html">Solver Interface API</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/docs/src/apireference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solver Interface API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solver-Interface-API-1" href="#Solver-Interface-API-1">Solver Interface API</a></h1><p>Some introduction to MPB API. List basic standalone methods.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.AbstractModel" href="#MathProgBase.AbstractModel"><code>MathProgBase.AbstractModel</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractModel</code></pre><p>Abstract supertype which represents a solver&#39;s in-memory representation of an optimization problem.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/SolverInterface.jl#L35-L40">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.AbstractNLPModel" href="#MathProgBase.AbstractNLPModel"><code>MathProgBase.AbstractNLPModel</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractNLPModel</code></pre><p>Abstract supertype which represents a solver&#39;s in-memory representation of a non-linear optimization problem.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/SolverInterface.jl#L20-L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.AbstractMathProgSolver" href="#MathProgBase.AbstractMathProgSolver"><code>MathProgBase.AbstractMathProgSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractMathProgSolver</code></pre><p>Abstract supertype for &quot;solver&quot; objects. A solver is a lightweight object used for selecting solvers and parameters. It does not store any instance data.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/SolverInterface.jl#L13-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.Model" href="#MathProgBase.Model"><code>MathProgBase.Model</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Model(solver::AbstractMathProgSolver)</code></pre><p>Create an instance of <code>AbstractModel</code> using the given solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/SolverInterface.jl#L43-L47">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.NLPModel" href="#MathProgBase.NLPModel"><code>MathProgBase.NLPModel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">NLPModel(solver::AbstractMathProgSolver)</code></pre><p>Create an instance of <code>AbstractNLPModel</code> using the given solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/SolverInterface.jl#L28-L32">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.optimize!" href="#MathProgBase.optimize!"><code>MathProgBase.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">optimize!(m::AbstractMathProgModel)</code></pre><p>Start the solution procedure.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/SolverInterface.jl#L59-L63">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.freemodel!" href="#MathProgBase.freemodel!"><code>MathProgBase.freemodel!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">freemodel!(m::AbstractMathProgModel)</code></pre><p>Release any resources and memory used by the model. Note that the Julia garbage collector takes care of this automatically, but automatic collection cannot always be forced. This method is useful for more precise control of resources, especially in the case of commercial solvers with licensing restrictions on the number of concurrent runs. Users must discard the model object after this method is invoked.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/SolverInterface.jl#L66-L75">source</a><br/></section><h2><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariableReference" href="#MathProgBase.VariableReference"><code>MathProgBase.VariableReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableReference</code></pre><p>A lightweight object used to reference variables in a model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/references.jl#L60-L64">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.candelete-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},MathProgBase.VariableReference}" href="#MathProgBase.candelete-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},MathProgBase.VariableReference}"><code>MathProgBase.candelete</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">candelete(m::AbstractMathProgModel, ref::VariableReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this variable can be removed from the model <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/references.jl#L69-L73">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.isvalid-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},MathProgBase.VariableReference}" href="#MathProgBase.isvalid-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},MathProgBase.VariableReference}"><code>MathProgBase.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(m::AbstractMathProgModel, ref::VariableReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this reference is valid for an active variable in the model <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/references.jl#L76-L81">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},MathProgBase.VariableReference}" href="#Base.delete!-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},MathProgBase.VariableReference}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">delete!(m::AbstractMathProgModel, ref::VariableReference)</code></pre><p>Delete the referenced variable from the model.</p><pre><code class="language-none">delete!(m::AbstractMathProgModel, refs::Vector{VariableReference})</code></pre><p>Delete the referenced variables in the vector <code>refs</code> from the model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/references.jl#L84-L92">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.addvariables!" href="#MathProgBase.addvariables!"><code>MathProgBase.addvariables!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addvariables!(m::AbstractMathProgModel, N::Int)::Vector{VariableReference}</code></pre><p>Add <code>N</code> scalar variables to the model, returning a vector of variable references.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/variables.jl#L1-L6">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.addvariable!" href="#MathProgBase.addvariable!"><code>MathProgBase.addvariable!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addvariable!(m::AbstractMathProgModel)::VariableReference</code></pre><p>Add a scalar variable to the model, returning a variable reference.</p><p>In addition, there is a special case for adding variables to existing linear problems.</p><pre><code class="language-none">addvariable!(m::AbstractMathProgModel,
    cref::Vector{Union{
            AffineConstraintRef{NonPositive},
            AffineConstraintRef{NonNegative},
            AffineConstraintRef{Zero},
            AffineConstraintRef{Interval}
        }},
    coefs)::VariableReference</code></pre><p>Add a variable with coefficients specified by <code>coefs</code> in the existing affine constraints given by the constraint references <code>cref</code>. If you want to add a variable with coefficients in a constraint that is not listed here (such as a quadratic term, or in the SOC), use <code>addvariable!(m)</code> and then <code>modifyconstraint!</code> instead.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/variables.jl#L9-L30">source</a><br/></section><h2><a class="nav-anchor" id="Objectives-1" href="#Objectives-1">Objectives</a></h2><p>How to add and set objectives.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.setobjective!" href="#MathProgBase.setobjective!"><code>MathProgBase.setobjective!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setobjective!(m::AbstractMathProgModel, b, a_varref::Vector{VariableReference}, a_coef, Q_vari::Vector{VariableReference}, Q_varj::Vector{VariableReference}, Q_coef, N::Int=1)</code></pre><p>Set the <code>N</code>&#39;th objective in the model <code>m</code> to be</p><div>\[a^Tx + b + \frac{1}{2}x^TQx\]</div><p>where <span>$a$</span> is a sparse vector specified in tuple form by <code>a_varref</code>, and <code>a_coef</code>; <span>$b$</span> is a scalar; and the symmetric matrix <span>$Q$</span> is defined by the triplets in <code>Q_vari</code>, <code>Q_varj</code>, <code>Q_coef</code>.</p><p>Duplicate indices in either the <span>$a$</span> vector or the <span>$Q$</span> matrix are accepted and will be summed together. Off-diagonal entries of <span>$Q$</span> will be mirrored, so either the upper triangular or lower triangular entries of <span>$Q$</span> should be provided. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms. <code>a_varref</code>, <code>Q_vari</code>, <code>Q_varj</code> should be collections of <code>VariableReference</code> objects.</p><pre><code class="language-none">setobjective!(m::AbstractMathProgModel, b, a_varref::Vector{VariableReference}, a_coef, N::Int=1)</code></pre><p>Set the <code>N</code>&#39;th objective in the model <code>m</code> to be</p><div>\[a^Tx + b\]</div><p>where <span>$a$</span> is a sparse vector specified in tuple form by <code>a_varref</code> and <code>a_coef</code> and <span>$b$</span> is a scalar.</p><p>Duplicate indices in either the <span>$a$</span> vector are accepted and will be summed together.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/objectives.jl#L1-L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.modifyobjective!" href="#MathProgBase.modifyobjective!"><code>MathProgBase.modifyobjective!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">modifyobjective!(m::AbstractMathProgModel, i::Int, args...)</code></pre><p>Modify elements of the <code>i</code>&#39;th objective depending on the arguments <code>args</code>. The <code>i</code>&#39;th objective will have the form:</p><div>\[    a_i^Tx + b_i + \frac{1}{2}x^TQ_ix\]</div><p>There are three cases.</p><p><strong>Modify Constant term</strong></p><pre><code class="language-none">modifyobjective!(m::AbstractMathProgModel, i::Int, b)</code></pre><p>Set the constant term of the <code>i</code>&#39;th row objective to <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyobjective!(m, 1, 1.0)</code></pre><p><strong>Modify Linear term</strong></p><pre><code class="language-none">modifyobjective!(m::AbstractMathProgModel, i::Int, a_varidx, a_coef)</code></pre><p>Set elements given by <code>a_varidx</code> in the linear term of the <code>i</code>&#39;th objective to <code>a_coef</code>. Either <code>a_varidx</code> and <code>a_coef</code> are both singletons, or they should be collections with equal length.</p><p>The behaviour of duplicate entries in <code>a_varidx</code> is undefined.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyobjective!(m, 1, v, 1.0)
modifyobjective!(m, 1, [v1, v2], [1.0, 2.0])</code></pre><p><strong>Modify Quadratic term</strong></p><pre><code class="language-none">modifyobjective!(m::AbstractMathProgModel, i::Int, Q_vari, Q_varj, Q_coef)</code></pre><p>Set the elements in the quadratic term of the <code>i</code>&#39;th objective specified by the triplets <code>Q_vari</code>, <code>Q_varj</code>, and <code>Q_coef</code>. Off-diagonal entries will be mirrored. <code>Q_vari</code>, <code>Q_varj</code> should be collections of <code>VariableReference</code> objects.</p><p>The behaviour of duplicate entries is undefined. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyobjective!(m, 1, v1, v2, 1.0)
modifyobjective!(m, 1, [v1, v2], [v1, v1], [1.0, 2.0])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/objectives.jl#L33-L89">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.getobjectiveconstant" href="#MathProgBase.getobjectiveconstant"><code>MathProgBase.getobjectiveconstant</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getobjectiveconstant(m, i::Int=1)</code></pre><p>Return the constant term in the <code>i</code>&#39;th objective.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/objectives.jl#L92-L96">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.getobjectiveaffine" href="#MathProgBase.getobjectiveaffine"><code>MathProgBase.getobjectiveaffine</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getobjectiveaffine(m, i::Int=1)</code></pre><p>Return the affine part of the <code>i</code>&#39;th objective in tuple form <code>(varref,coef)</code> where <code>varref</code> is a <code>VariableReference</code>, and <code>coef</code> is a coefficient. Output is a tuple of two vectors.</p><pre><code class="language-none">getobjectiveaffine(m, v::VariableReference, i::Int=1)</code></pre><p>Return the coefficient for the variable <code>v</code> in the affine part of the <code>i</code>&#39;th objective.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/objectives.jl#L99-L107">source</a><br/></section><h2><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h2><p>How to add and modify constraints.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariablewiseConstraintReference" href="#MathProgBase.VariablewiseConstraintReference"><code>MathProgBase.VariablewiseConstraintReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablewiseConstraintReference{T}</code></pre><p>A lightweight object used to reference variablewise constraints in a model. The parameter <code>T</code> is the type of set constraint referenced.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/references.jl#L1-L6">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.AffineConstraintReference" href="#MathProgBase.AffineConstraintReference"><code>MathProgBase.AffineConstraintReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AffineConstraintReference{T}</code></pre><p>A lightweight object used to reference affine-in-set constraints in a model. The parameter <code>T</code> is the type of set constraint referenced.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/references.jl#L11-L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.QuadraticConstraintReference" href="#MathProgBase.QuadraticConstraintReference"><code>MathProgBase.QuadraticConstraintReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QuadraticConstraintReference{T}</code></pre><p>A lightweight object used to reference quadratic-in-set constraints in a model. The parameter <code>T</code> is the type of set constraint referenced.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/references.jl#L21-L26">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.candelete-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},Union{MathProgBase.AffineConstraintReference, MathProgBase.QuadraticConstraintReference, MathProgBase.VariablewiseConstraintReference}}" href="#MathProgBase.candelete-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},Union{MathProgBase.AffineConstraintReference, MathProgBase.QuadraticConstraintReference, MathProgBase.VariablewiseConstraintReference}}"><code>MathProgBase.candelete</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">candelete(m::AbstractMathProgModel, ref::ConstraintReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this constraint can be removed from the model <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/references.jl#L33-L37">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.isvalid-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},Union{MathProgBase.AffineConstraintReference, MathProgBase.QuadraticConstraintReference, MathProgBase.VariablewiseConstraintReference}}" href="#MathProgBase.isvalid-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},Union{MathProgBase.AffineConstraintReference, MathProgBase.QuadraticConstraintReference, MathProgBase.VariablewiseConstraintReference}}"><code>MathProgBase.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(m::AbstractMathProgModel, ref::ConstraintReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this reference is valid for an active constraint in the model <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/references.jl#L40-L45">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},Union{MathProgBase.AffineConstraintReference, MathProgBase.QuadraticConstraintReference, MathProgBase.VariablewiseConstraintReference}}" href="#Base.delete!-Tuple{Union{MathProgBase.AbstractModel, MathProgBase.AbstractNLPModel},Union{MathProgBase.AffineConstraintReference, MathProgBase.QuadraticConstraintReference, MathProgBase.VariablewiseConstraintReference}}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">delete!(m::AbstractMathProgModel, ref::ConstraintReference)</code></pre><p>Delete the referenced constraint from the model.</p><pre><code class="language-none">delete!(m::AbstractMathProgModel, refs::Vector{ConstraintReference})</code></pre><p>Delete the referenced constraints in the vector <code>refs</code> from the model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/references.jl#L48-L56">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.addconstraint!" href="#MathProgBase.addconstraint!"><code>MathProgBase.addconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addconstraint!(m::AbstractMathProgModel, b, a_constridx, a_varref::Vector{VariableReference}, a_coef, Q_constridx, Q_vari::Vector{VariableReference}, Q_varj::Vector{VariableReference}, Q_coef, S::AbstractSet)::QuadraticConstraintReference{typeof(S)}</code></pre><p>Add the quadratic-in-set constraint</p><div>\[Ax + b + q(x) \in S\]</div><p>where <span>$A$</span> is a sparse matrix specified in triplet form by <code>a_constridx</code>, <code>a_varref</code>, and <code>a_coef</code>; <span>$b$</span> is a vector; <span>$q(x)$</span> is a vector with component <span>$(q(x))_k$</span> defined to be <span>$\frac{1}{2}x^TQ_kx$</span> where the symmetric matrix <span>$Q_k$</span> is defined by the triplets in <code>Q_vari</code>, <code>Q_varj</code>, <code>Q_coef</code> for which <code>Q_constridx</code> equals <code>k</code>; and the set <span>$S$</span> is defined by <code>S</code>.</p><p>Duplicate indices in either the <span>$A$</span> or the <span>$Q$</span> matrix are accepted and will be summed together. Off-diagonal entries of <span>$Q$</span> will be mirrored, so either the upper triangular or lower triangular entries of <span>$Q$</span> should be provided. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms. <code>a_varref</code>, <code>Q_vari</code>, <code>Q_varj</code> should be collections of <code>VariableReference</code> objects.</p><pre><code class="language-none">addconstraint!(m::AbstractMathProgModel, b, a_varref::Vector{VariableReference}, a_coef, Q_vari::Vector{VariableReference}, Q_varj::Vector{VariableReference}, Q_coef, S::AbstractSet)::QuadraticConstraintReference{typeof(S)}</code></pre><p>A specialized version of <code>addconstraint!</code> for one-dimensional sets. Add the constraint</p><div>\[a^Tx + b + \frac{1}{2}x^TQx \in S\]</div><p>where <span>$a$</span> is a sparse vector specified in tuple form by <code>a_varref</code>, and <code>a_coef</code>; <span>$b$</span> is a scalar; the symmetric matrix <span>$Q$</span> is defined by the triplets in <code>Q_vari</code>, <code>Q_varj</code>, <code>Q_coef</code>; and the set <span>$S$</span> is defined by <code>S</code>.</p><pre><code class="language-none">addconstraint!(m::AbstractMathProgModel, b, a_constridx, a_varref::Vector{VariableReference}, a_coef, S::AbstractSet)::AffineConstraintReference{typeof(S)}</code></pre><p>Add the affine-in-set constraint</p><div>\[Ax + b \in S\]</div><p>where <span>$A$</span> is a sparse matrix specified in triplet form by <code>a_constridx</code>, <code>a_varref</code>, and <code>a_coef</code>; <span>$b$</span> is a vector; and the set <span>$S$</span> is defined by <code>S</code>.</p><p>Duplicate indices either <span>$A$</span> are accepted and will be summed together.</p><pre><code class="language-none">addconstraint!(m::AbstractMathProgModel, b, a_varref::Vector{VariableReference}, a_coef, S::AbstractSet)::AffineConstraintReference{typeof(S)}</code></pre><p>A specialized version of <code>addconstraint!</code> for one-dimensional sets. Add the constraint</p><div>\[a^Tx + b \in S\]</div><p>where <span>$a$</span> is a sparse vector specified in tuple form by <code>a_varref</code>, and <code>a_coef</code>; <span>$b$</span> is a scalar; and the set <span>$S$</span> is defined by <code>S</code>.</p><pre><code class="language-none">addconstraint!(m::AbstractMathProgModel, varref::Vector{VariableReference}, S::AbstractSet)::VariablewiseConstraintReference{typeof(S)}</code></pre><p>A specialized version of <code>addconstraint!</code> for variablewise constraints. Add the constraint</p><div>\[x_{varref} \in S\]</div><p>where <code>varref</code> is a vector of variable references to specifiy the subset of the subvector of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/constraints.jl#L1-L60">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.modifyconstraint!" href="#MathProgBase.modifyconstraint!"><code>MathProgBase.modifyconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">modifyconstraint!(m::AbstractMathProgModel, c::ConstraintReference, i::Int, args...)</code></pre><p>Modify elements of the <code>i</code>&#39;th row of the constraint <code>c</code> depending on the arguments <code>args</code>. The <code>i</code>&#39;th row will have the form</p><div>\[    a_i^Tx + b_i + \frac{1}{2}x^TQ_ix \in S\]</div><p>There are three cases.</p><p><strong>Modify Constant term</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractMathProgModel, c::ConstraintReference, i::Int, b)</code></pre><p>Set the constant term of the <code>i</code>&#39;th row in the constraint <code>c</code> to <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(m, c, 1, 1.0)</code></pre><p><strong>Modify Linear term</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractMathProgModel, c::ConstraintReference, i::Int, a_varref::Vector{VariableReference}, a_coef)</code></pre><p>Set elements given by <code>a_varref</code> in the linear term of the <code>i</code>&#39;th element in the constraint <code>c</code> to <code>a_coef</code>. Either <code>a_varref</code> and <code>a_coef</code> are both singletons, or they should be collections with equal length.</p><p>The behaviour of duplicate entries in <code>a_varref</code> is undefined.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(m, c, v, 1.0)
modifyconstraint!(m, c, [v1, v2], [1.0, 2.0])</code></pre><p><strong>Modify Quadratic term</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractMathProgModel, c::ConstraintReference, i::Int, Q_vari, Q_varj, Q_coef)</code></pre><p>Set the elements in the quadratic term of the <code>i</code>&#39;th element of the constraint <code>c</code> specified by the triplets <code>Q_vari</code>, <code>Q_varj</code>, and <code>Q_coef</code>. Off-diagonal entries will be mirrored. <code>Q_vari</code>, <code>Q_varj</code> should be collections of <code>VariableReference</code> objects.</p><p>The behaviour of duplicate entries is undefined. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(m, c, v1, v2, 1.0)
modifyconstraint!(m, c, [v1, v2], [v1, v1], [1.0, 2.0])</code></pre><p><strong>Modify Set</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractMathProgModel, c::ConstraintReference{S}, set::S)</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintReference{Interval}</code></p><pre><code class="language-julia">modifyconstraint!(m, c, Interval(0, 5))
modifyconstraint!(m, c, NonPositive) # errors</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/constraints.jl#L63-L136">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.getconstraintconstant" href="#MathProgBase.getconstraintconstant"><code>MathProgBase.getconstraintconstant</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconstraintconstant(m::AbstractMathProgModel, c::ConstraintReference, i::Int)</code></pre><p>Return the constant term of the <code>i</code>th row of the constraint corresponding to <code>c</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/constraints.jl#L139-L143">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.getconstraintaffine" href="#MathProgBase.getconstraintaffine"><code>MathProgBase.getconstraintaffine</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconstraintaffine(m::AbstractMathProgModel, c::ConstraintReference)</code></pre><p>Return the <span>$A$</span> matrix of the constraint corresponding to <code>c</code> in triplet form <code>(row,varref,coef)</code> where <code>row</code> is an integer, <code>varref</code> is a <code>VariableReference</code>, and <code>coef</code> is a coefficient. Output is a tuple of three vectors.</p><pre><code class="language-none">getconstraintaffine(m::AbstractMathProgModel, c::ConstraintReference, i::Int)</code></pre><p>Return the <code>i</code>th row of the <span>$A$</span> matrix of the constraint corresponding to <code>c</code> in tuple form <code>(varref,coef)</code> where <code>varref</code> is a <code>VariableReference</code>, and <code>coef</code> is a coefficient. Output is a tuple of two vectors.</p><pre><code class="language-none">getconstraintaffine(m::AbstractMathProgModel, c::ConstraintReference, i::Int, v::VariableReference)</code></pre><p>Return the element of the <span>$A$</span> matrix of the constraint corresponding to <code>c</code> in row <code>i</code> and variable <code>v</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/constraints.jl#L146-L158">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.getconstraintquadratic" href="#MathProgBase.getconstraintquadratic"><code>MathProgBase.getconstraintquadratic</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconstraintquadratic(m::AbstractMathProgModel, c::ConstraintReference, i::Int)</code></pre><p>Return the <span>$Q$</span> matrix of the <code>i</code>th row of the constraint corresponding to <code>c</code> in triplet form <code>(varref_a,varref_b,coef)</code> where <code>varref_a</code> is a <code>VariableReference</code>, <code>varref_b</code> is a <code>VariableReference</code>, and <code>coef</code> is a coefficient. Output is a tuple of three vectors. The <span>$Q$</span> matrix must be symmetric, and only one of the two symmetric elements is returned.</p><pre><code class="language-none">getconstraintquadratic(m::AbstractMathProgModel, c::ConstraintReference, i::Int, v1::VariableReference, v2::VariableReference)</code></pre><p>Return the element <code>(v1,v2)</code> of the <span>$Q$</span> matrix of the <code>i</code>th row of the constraint corresponding to <code>c</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/constraints.jl#L161-L169">source</a><br/></section><h2><a class="nav-anchor" id="Sets-1" href="#Sets-1">Sets</a></h2><p>List of sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.NonNegative" href="#MathProgBase.NonNegative"><code>MathProgBase.NonNegative</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NonNegative(n)</code></pre><p>The nonnegative orthant <span>$\{ x \in \mathbb{R}^n : x \ge 0 \}$</span> where the dimension <span>$n$</span> is specified by the field <code>n</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/sets.jl#L9-L13">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.NonPositive" href="#MathProgBase.NonPositive"><code>MathProgBase.NonPositive</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NonPositive(n)</code></pre><p>The nonpositive orthant <span>$\{ x \in \mathbb{R}^n : x \le 0 \}$</span> where the dimension <span>$n$</span> is specified by the field <code>n</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/sets.jl#L18-L22">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.Zero" href="#MathProgBase.Zero"><code>MathProgBase.Zero</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Zero(n)</code></pre><p>The set <span>$\{0\}^n$</span> where the dimension <span>$n$</span> is specified by the field <code>n</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/sets.jl#L27-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.Interval" href="#MathProgBase.Interval"><code>MathProgBase.Interval</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Interval(lower,upper)</code></pre><p>The set <span>$[l,u] \subseteq \mathbb{R}^n$</span> where <span>$l$</span> and <span>$u$</span> are specified by <code>lower</code> and <code>upper</code>, respectively. We allow <code>lower</code> and <code>upper</code> to be <code>-Inf</code> or <code>Inf</code>, in which case the set is interpreted as a one-sided interval.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/sets.jl#L37-L41">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.SecondOrderCone" href="#MathProgBase.SecondOrderCone"><code>MathProgBase.SecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SecondOrderCone(n)</code></pre><p>The second-order cone or the Lorenz cone of dimension <code>n</code> defined as</p><div>\[\{ (t,x) \in \mathbb{R}^n : t \ge ||x||_2 \}.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/sets.jl#L49-L57">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.Integers" href="#MathProgBase.Integers"><code>MathProgBase.Integers</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Integers(n)</code></pre><p>The set of integers <span>$\mathbb{Z}^n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/sets.jl#L65-L69">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.Binaries" href="#MathProgBase.Binaries"><code>MathProgBase.Binaries</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Binaries(n)</code></pre><p>The set of binary vectors <span>$\{0,1\}^n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/sets.jl#L74-L78">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.SOS1" href="#MathProgBase.SOS1"><code>MathProgBase.SOS1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SOS1(weights::Vector{T}) where T</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 1. Of the variables in the set, at most one can be nonzero. The <span>$weights$</span> induce an ordering of the variables; as such, they should be unique values. The <span>$k$</span>-th element in the set corresponds to the <span>$k$</span>-th weight in <span>$weights$</span>.</p><p>See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/sets.jl#L86-L92">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.SOS2" href="#MathProgBase.SOS2"><code>MathProgBase.SOS2</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SOS2(weights::Vector{T}) where T</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 2. Of the variables in the set, at most two can be nonzero, and if two are nonzero, they must be adjacent in the ordering of the set. The <span>$weights$</span> induce an ordering of the variables; as such, they should be unique values. The <span>$k$</span>-th element in the set corresponds to the <span>$k$</span>-th weight in <span>$weights$</span>.</p><p>See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/sets.jl#L98-L104">source</a><br/></section><h2><a class="nav-anchor" id="Attributes-1" href="#Attributes-1">Attributes</a></h2><p>These are used to get and set properties of the model.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.AbstractAttribute" href="#MathProgBase.AbstractAttribute"><code>MathProgBase.AbstractAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L1-L6">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.cangetattribute" href="#MathProgBase.cangetattribute"><code>MathProgBase.cangetattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cangetattribute(m::AbstractMathProgModel, attr::AbstractAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the model <code>m</code> currently has a value for the attributed specified by attribute type <code>attr</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L39-L44">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.getattribute" href="#MathProgBase.getattribute"><code>MathProgBase.getattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getattribute(m::AbstractMathProgModel, attr::AbstractAttribute, extra_args...)</code></pre><p>Return an attribute of the model <code>m</code> specified by attribute type <code>attr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">getattribute(m, ObjectiveValue())
getattribute(m, VariableResult(), ref)
getattribute(m, VariableResult(5), [ref1,ref2])
getattribute(m, OtherAttribute(&quot;something specific to cplex&quot;))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L9-L22">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.getattribute!" href="#MathProgBase.getattribute!"><code>MathProgBase.getattribute!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getattribute!(output, m::AbstractMathProgModel, attr::AbstractAttribute, extra_args...)</code></pre><p>An in-place version of <code>getattribute</code>. Return an attribute of the model <code>m</code> specified by attribute type <code>attr</code> into output vector <code>attr</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L29-L33">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.cansetattribute" href="#MathProgBase.cansetattribute"><code>MathProgBase.cansetattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cansetattribute(m::AbstractMathProgModel, attr::AbstractAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the model <code>m</code> will accept a <code>setattribute!</code> call for the attributed specified by attribute type <code>attr</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L48-L53">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.setattribute!" href="#MathProgBase.setattribute!"><code>MathProgBase.setattribute!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setattribute!(m::AbstractMathProgModel, attr::AbstractAttribute, ...)</code></pre><p>Set an attribute of the model <code>m</code> specified by attribute type <code>attr</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L57-L61">source</a><br/></section><h3><a class="nav-anchor" id="Scalar-Attributes-1" href="#Scalar-Attributes-1">Scalar Attributes</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ObjectiveValue" href="#MathProgBase.ObjectiveValue"><code>MathProgBase.ObjectiveValue</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveValue(resultidx::Int=1, objectiveindex::Int=1)</code></pre><p>The objective value of the <code>resultindex</code>&#39;th primal result of the <code>objectiveindex</code>&#39;th objective.</p><p>Both <code>resultindex</code> and <code>objectiveindex</code> default to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L68-L74">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ObjectiveBound" href="#MathProgBase.ObjectiveBound"><code>MathProgBase.ObjectiveBound</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveBound()</code></pre><p>The best known bound on the optimal objective value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L81-L85">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.RelativeGap" href="#MathProgBase.RelativeGap"><code>MathProgBase.RelativeGap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RelativeGap()</code></pre><p>The final relative optimality gap as optimization terminated. That is, <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L88-L92">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.SolveTime" href="#MathProgBase.SolveTime"><code>MathProgBase.SolveTime</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SolveTime()</code></pre><p>The total elapsed solution time (in seconds) as reported by the solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L95-L99">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.Sense" href="#MathProgBase.Sense"><code>MathProgBase.Sense</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Sense()</code></pre><p>The optimization sense of the model, an <code>OptimizationSense</code> with value <code>MinSense</code> or <code>MaxSense</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L102-L106">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.SimplexIterations" href="#MathProgBase.SimplexIterations"><code>MathProgBase.SimplexIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SimplexIterations()</code></pre><p>The cumulative number of simplex iterations during the optimization process. In particular, for a MIP the total simplex iterations for all nodes.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L111-L115">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.BarrierIterations" href="#MathProgBase.BarrierIterations"><code>MathProgBase.BarrierIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BarrierIterations()</code></pre><p>The cumulative number of barrier iterations during the optimization process.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L118-L122">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.NodeCount" href="#MathProgBase.NodeCount"><code>MathProgBase.NodeCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NodeCount()</code></pre><p>The total number of branch-and-bound nodes explored.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L125-L129">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.RawSolver" href="#MathProgBase.RawSolver"><code>MathProgBase.RawSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RawSolver()</code></pre><p>An object that may be used to access a solver-specific API for this model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L132-L136">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ResultCount" href="#MathProgBase.ResultCount"><code>MathProgBase.ResultCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ResultCount()</code></pre><p>The number of results available.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L139-L143">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariableCount" href="#MathProgBase.VariableCount"><code>MathProgBase.VariableCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableCount()</code></pre><p>The number of variables in the model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L146-L150">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ConstraintCount" href="#MathProgBase.ConstraintCount"><code>MathProgBase.ConstraintCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintCount{T}()</code></pre><p>The number of constraints of type T in the model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L153-L157">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.SupportsVariablewiseConstraint" href="#MathProgBase.SupportsVariablewiseConstraint"><code>MathProgBase.SupportsVariablewiseConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsVariablewiseConstraint{T}()</code></pre><p>A <code>Bool</code> indicating whether the solver or model supports a variablewise constraint in the set <span>$S$</span> which is a set of type <code>T</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L160-L166">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.SupportsAffineConstraint" href="#MathProgBase.SupportsAffineConstraint"><code>MathProgBase.SupportsAffineConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsAffineConstraint{T}()</code></pre><p>A <code>Bool</code> indicating whether the solver or model supports a constraint of of the form &quot;affine expression&quot; in <span>$S$</span> where <span>$S$</span> is a set of type <code>T</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L169-L175">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.SupportsQuadraticConstraint" href="#MathProgBase.SupportsQuadraticConstraint"><code>MathProgBase.SupportsQuadraticConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsQuadraticConstraint{T}()</code></pre><p>A <code>Bool</code> indicating whether the solver or model supports a constraint of of the form &quot;quadratic expression&quot; in <span>$S$</span> where <span>$S$</span> is a set of type <code>T</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L178-L184">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.TerminationStatus" href="#MathProgBase.TerminationStatus"><code>MathProgBase.TerminationStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TerminationStatus()</code></pre><p>A <code>TerminationStatusCode</code> explaining why the solver stopped.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L330-L334">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.PrimalStatus" href="#MathProgBase.PrimalStatus"><code>MathProgBase.PrimalStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PrimalStatus(N)
PrimalStatus()</code></pre><p>The <code>ResultStatusCode</code> of the primal result <code>N</code>. If <code>N</code> is omitted, it defaults to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L391-L396">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.DualStatus" href="#MathProgBase.DualStatus"><code>MathProgBase.DualStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualStatus(N)
DualStatus()</code></pre><p>The <code>ResultStatusCode</code> of the dual result <code>N</code>. If <code>N</code> is omitted, it defaults to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L402-L407">source</a><br/></section><h3><a class="nav-anchor" id="Variable-Attributes-1" href="#Variable-Attributes-1">Variable Attributes</a></h3><p>These attributes are associated with variables. Calls to <code>getattribute</code> and <code>setattribute!</code> should include as an argument a single <code>VariableReference</code> or a vector of <code>VariableReference</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariablePrimalStart" href="#MathProgBase.VariablePrimalStart"><code>MathProgBase.VariablePrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablePrimalStart()</code></pre><p>An initial assignment of the variables that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L191-L196">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariableLowerBoundDualStart" href="#MathProgBase.VariableLowerBoundDualStart"><code>MathProgBase.VariableLowerBoundDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableLowerBoundDualStart()</code></pre><p>An initial assignment of the variable lower-bound duals that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L199-L204">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariableUpperBoundDualStart" href="#MathProgBase.VariableUpperBoundDualStart"><code>MathProgBase.VariableUpperBoundDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableUpperBoundDualStart()</code></pre><p>An initial assignment of the variable upper-bound duals that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L207-L212">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariableLowerBound" href="#MathProgBase.VariableLowerBound"><code>MathProgBase.VariableLowerBound</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableLowerBound()</code></pre><p>Lower-bound constraints on variables. <code>-Inf</code> is valid as no bound.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L215-L219">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariableUpperBound" href="#MathProgBase.VariableUpperBound"><code>MathProgBase.VariableUpperBound</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableUpperBound()</code></pre><p>Upper-bound constraints for the variables. <code>Inf</code> is valid as no bound.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L222-L226">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariablePrimal" href="#MathProgBase.VariablePrimal"><code>MathProgBase.VariablePrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablePrimal(N)
VariablePrimal()</code></pre><p>The assignment to the primal variables in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L229-L234">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariableLowerBoundDual" href="#MathProgBase.VariableLowerBoundDual"><code>MathProgBase.VariableLowerBoundDual</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableLowerBoundDual(N)</code></pre><p>The assignment to the duals on the variable lower bounds in result <code>N</code>. If <code>N</code> is omitted, it is interpreted as 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L240-L244">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariableUpperBoundDual" href="#MathProgBase.VariableUpperBoundDual"><code>MathProgBase.VariableUpperBoundDual</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableUpperBoundDual(N)</code></pre><p>The assignment to the duals on the variable upper bounds in result <code>N</code>. If <code>N</code> is omitted, it is interpreted as 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L250-L254">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.VariableBasisStatus" href="#MathProgBase.VariableBasisStatus"><code>MathProgBase.VariableBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableBasisStatus()</code></pre><p>Returns the <code>BasisStatusCode</code> of a given variable, with respect to an available optimal solution basis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L260-L264">source</a><br/></section><h3><a class="nav-anchor" id="Constraint-Attributes-1" href="#Constraint-Attributes-1">Constraint Attributes</a></h3><p>These attributes are associated with constraints. Calls to <code>getattribute</code> and <code>setattribute!</code> should include as an argument a single <code>ConstraintReference</code> or a vector of <code>ConstriaintReference{T}</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ConstraintPrimalStart" href="#MathProgBase.ConstraintPrimalStart"><code>MathProgBase.ConstraintPrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintPrimalStart()</code></pre><p>An initial assignment of the constraint primal values that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L281-L286">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ConstraintDualStart" href="#MathProgBase.ConstraintDualStart"><code>MathProgBase.ConstraintDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintDualStart()</code></pre><p>An initial assignment of the constriant duals that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L289-L294">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ConstraintPrimal" href="#MathProgBase.ConstraintPrimal"><code>MathProgBase.ConstraintPrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintPrimal(N)
ConstraintPrimal()</code></pre><p>The assignment to the constraint primal values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L297-L302">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ConstraintDual" href="#MathProgBase.ConstraintDual"><code>MathProgBase.ConstraintDual</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintDual(N)
ConstraintDual()</code></pre><p>The assignment to the constraint dual values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L308-L313">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ConstraintBasisStatus" href="#MathProgBase.ConstraintBasisStatus"><code>MathProgBase.ConstraintBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintBasisStatus()</code></pre><p>Returns the <code>BasisStatusCode</code> of a given constraint, with respect to an available optimal solution basis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L319-L323">source</a><br/></section><h2><a class="nav-anchor" id="Status-Codes-1" href="#Status-Codes-1">Status Codes</a></h2><h3><a class="nav-anchor" id="Termination-Status-1" href="#Termination-Status-1">Termination Status</a></h3><p>The <code>TerminationStatus</code> attribute is meant to explain the reason why the solver stopped executing. The value of the attribute is of type <code>TerminationStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.TerminationStatusCode" href="#MathProgBase.TerminationStatusCode"><code>MathProgBase.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the solver stopped executing.</p><p><strong>OK</strong></p><p>These are generally OK statuses.</p><ul><li><p><code>Success</code>: the algorithm ran successfully and has a result. This includes cases where the algorithm converges to an infeasible point (NLP) or converges to a solution of a homogeneous self-dual problem and has a certificate of primal/dual infeasibility.</p></li><li><p><code>AlmostSuccess</code>: the algorithm <em>almost</em> ran successfully (e.g., to relaxed convergence tolerances) and has a result.</p></li><li><p><code>InfeasibleNoResult</code>: the algorithm stopped because it decided that the problem is infeasible but does not have a result to return.</p></li><li><p><code>UnboundedNoResult</code>: the algorithm stopped because it decided that the problem is unbounded but does not have a result to return.</p></li><li><p><code>InfeasibleOrUnbounded</code>: the algorithm stopped because it decided that the problem is infeasible or unbounded; no result is available. This occasionally happens during MIP presolve.</p></li></ul><p><strong>Limits</strong></p><p>The solver stopped because of some user-defined limit. To be documented: <code>IterationLimit</code>, <code>TimeLimit</code>, <code>NodeLimit</code>, <code>SolutionLimit</code>, <code>MemoryLimit</code>, <code>ObjectiveLimit</code>, <code>NormLimit</code>, <code>OtherLimit</code>.</p><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><p><code>SlowProgress</code>: the algorithm stopped because it was unable to continue making progress towards the solution. <code>AlmostSuccess</code> should be used if there is additional information that relaxed convergence tolerances are satisfied.</p></li></ul><p>To be documented: <code>NumericalError</code>, <code>InvalidModel</code>, <code>InvalidOption</code>, <code>Interrupted</code>, <code>OtherError</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L337-L369">source</a><br/></section><h3><a class="nav-anchor" id="Result-Status-1" href="#Result-Status-1">Result Status</a></h3><p>The <code>PrimalStatus</code> and <code>DualStatus</code> attributes are meant to explain how to interpret the result returned by the solver. The value of the attributes are of type <code>ResultStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ResultStatusCode" href="#MathProgBase.ResultStatusCode"><code>MathProgBase.ResultStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><p><code>FeasiblePoint</code></p></li><li><p><code>NearlyFeasiblePoint</code></p></li><li><p><code>InfeasiblePoint</code></p></li><li><p><code>InfeasibilityCertificate</code></p></li><li><p><code>NearlyInfeasibilityCertificate</code></p></li><li><p><code>ReductionCertificate</code></p></li><li><p><code>NearlyReductionCertificate</code></p></li><li><p><code>Unknown</code></p></li><li><p><code>Other</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L374-L388">source</a><br/></section><h3><a class="nav-anchor" id="Basis-Status-1" href="#Basis-Status-1">Basis Status</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.BasisStatusCode" href="#MathProgBase.BasisStatusCode"><code>MathProgBase.BasisStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BasisStatusCode</code></pre><p>An Enum of possible values for the <code>VariableBasisStatus</code> and <code>ConstraintBasisStatus</code> attribute. This explains the status of a given element with respect to an optimal solution basis. Possible values are:     * <code>Basic</code>: element is in the basis.     * <code>Nonbasic</code>: element is not in the basis.     * <code>NonbasicAtLower</code>: element is not in the basis and is at its lower bound.     * <code>NonbasicAtUpper</code>: element is not in the basis and is at its upper bound.     * <code>SuperBasic</code>: element is not in the basis but is also not at one of its bounds.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/attributes.jl#L267-L276">source</a><br/></section><h2><a class="nav-anchor" id="Duals-1" href="#Duals-1">Duals</a></h2><p>We take the convention that duals on variable lower bounds should be nonnegative, duals on variable upper bounds should be nonpositive, and duals on closed convex cones should belong to the dual cone.</p><h2><a class="nav-anchor" id="Nonlinear-Programming-(NLP)-1" href="#Nonlinear-Programming-(NLP)-1">Nonlinear Programming (NLP)</a></h2><h3><a class="nav-anchor" id="NLP-Methods-1" href="#NLP-Methods-1">NLP Methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.loadnlp!" href="#MathProgBase.loadnlp!"><code>MathProgBase.loadnlp!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loadnlp!(m::AbstractNonlinearModel, numVar, numConstr, l, u, lb, ub, sense::OptimizationSense, d::AbstractNLPEvaluator)</code></pre><p>Loads the nonlinear programming problem into the model. The parameter <code>numVar</code> is the number of variables in the problem, <code>numConstr</code> is the number of constraints, <code>l</code> contains the variable lower bounds, <code>u</code> contains the variable upper bounds, <code>lb</code> contains the constraint lower bounds, and <code>ub</code> contains the constraint upper bounds. Sense contains the symbol <code>:Max</code> or <code>:Min</code>, indicating the direction of optimization. The final parameter <code>d</code> is an instance of an <code>AbstractNLPEvaluator</code>, described below, which may be queried for evaluating <span>$f$</span> and <span>$g$</span> and their corresponding derivatives.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L38-L42">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.initialize" href="#MathProgBase.initialize"><code>MathProgBase.initialize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">initialize(d::AbstractNLPEvaluator, requested_features::Vector{Symbol})</code></pre><p>Must be called before any other methods. The vector <code>requested_features</code> lists features requested by the solver. These may include <code>:Grad</code> for gradients of <span>$f$</span>, <code>:Jac</code> for explicit Jacobians of <span>$g$</span>, <code>:JacVec</code> for Jacobian-vector products, <code>:HessVe</code> for Hessian-vector and Hessian-of-Lagrangian-vector products, <code>:Hess</code> for explicit Hessians and Hessian-of-Lagrangians, and <code>:ExprGraph</code> for expression graphs.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L46-L55">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.features_available" href="#MathProgBase.features_available"><code>MathProgBase.features_available</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">features_available(d::AbstractNLPEvaluator)</code></pre><p>Returns the subset of features available for this problem instance, as a list of symbols in the same format as in <code>initialize</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L59-L64">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_f" href="#MathProgBase.eval_f"><code>MathProgBase.eval_f</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_f(d::AbstractNLPEvaluator, x)</code></pre><p>Evaluate <span>$f(x)$</span>, returning a scalar value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L68-L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_grad_f" href="#MathProgBase.eval_grad_f"><code>MathProgBase.eval_grad_f</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_grad_f(d::AbstractNLPEvaluator, g, x)</code></pre><p>Evaluate <span>$\nabla f(x)$</span> as a dense vector, storing  the result in the vector <code>g</code> which must be of the appropriate size.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L85-L90">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.jac_structure" href="#MathProgBase.jac_structure"><code>MathProgBase.jac_structure</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">jac_structure(d::AbstractNLPEvaluator)</code></pre><p>Returns the sparsity structure of the Jacobian matrix, <span>$J_g(x) = \left[ \begin{array}{c} \nabla g_1(x) \\ \nabla g_2(x) \\ \vdots \\ \nabla g_m(x) \end{array} \right]$</span> where <span>$g_i$</span> is the <span>$i\text{th}$</span> component of <span>$g$</span>. The sparsity structure is assumed to be independent of the point <span>$x$</span>. Returns a tuple <span>$(I,J)$</span> where <span>$I$</span> contains the row indices and <span>$J$</span> contains the column indices of each structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L94-L98">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.hesslag_structure" href="#MathProgBase.hesslag_structure"><code>MathProgBase.hesslag_structure</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hesslag_structure(d::AbstractNLPEvaluator)</code></pre><p>Returns the sparsity structure of the Hessian-of-the-Lagrangian matrix  <span>$\nabla^2 f + \sum_{i=1}^m \nabla^2 g_i$</span> as a tuple <span>$(I,J)$</span> where <span>$I$</span> contains the row indices and <span>$J$</span> contains the column indices of each structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together. Any mix of lower and upper-triangular indices is valid. Elements <span>$(i,j)$</span> and <span>$(j,i)$</span>, if both present, should be treated as duplicates.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L102-L110">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_jac_g" href="#MathProgBase.eval_jac_g"><code>MathProgBase.eval_jac_g</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_jac_g(d::AbstractNLPEvaluator, J, x)</code></pre><p>Evaluates the sparse Jacobian matrix <span>$J_g(x) = \left[ \begin{array}{c} \nabla g_1(x) \\ \nabla g_2(x) \\ \vdots \\ \nabla g_m(x) \end{array} \right]$</span>. The result is stored in the vector <code>J</code> in the same order as the indices returned by <code>jac_structure</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L114-L120">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_jac_prod" href="#MathProgBase.eval_jac_prod"><code>MathProgBase.eval_jac_prod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_jac_prod(d::AbstractNLPEvaluator, y, x, w)</code></pre><p>Computes the Jacobian-vector product <span>$J_g(x)w$</span>, storing the result in the vector <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L124-L128">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_jac_prod_t" href="#MathProgBase.eval_jac_prod_t"><code>MathProgBase.eval_jac_prod_t</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_jac_prod_t(d::AbstractNLPEvaluator, y, x, w)</code></pre><p>Computes the Jacobian-transpose-vector product <span>$J_g(x)^T w$</span>, storing the result in the vector <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L132-L138">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_hesslag_prod" href="#MathProgBase.eval_hesslag_prod"><code>MathProgBase.eval_hesslag_prod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_hesslag_prod(d::AbstractNLPEvaluator, h, x, v, σ, μ)</code></pre><p>Given scalar weight <span>$σ$</span> and vector of constraint weights <span>$μ$</span>, computes the Hessian-of-the-Lagrangian-vector product <span>$\left( \sigma \nabla^2 f(x) + \sum_{i=1}^m \mu_i \nabla^2 g_i(x) \right)v$</span>,  storing the result in the vector <span>$h$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L142-L147">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_hesslag" href="#MathProgBase.eval_hesslag"><code>MathProgBase.eval_hesslag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_hesslag(d::AbstractNLPEvaluator, H, x, σ, μ)</code></pre><p>Given scalar weight <code>σ</code> and vector of constraint weights <code>μ</code>,  computes the sparse Hessian-of-the-Lagrangian matrix  <span>$\sigma \nabla^2 f(x) + \sum_{i=1}^m \mu_i \nabla^2 g_i(x)$</span>,  storing the result in the vector <code>H</code> in the same order as the indices returned by <code>hesslag_structure</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L151-L159">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.isobjlinear-Tuple{MathProgBase.AbstractNLPEvaluator}" href="#MathProgBase.isobjlinear-Tuple{MathProgBase.AbstractNLPEvaluator}"><code>MathProgBase.isobjlinear</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isobjlinear(::AbstractNLPEvaluator)</code></pre><p><code>true</code> if the objective function is known to be linear, <code>false</code> otherwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L195-L200">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.isobjquadratic-Tuple{MathProgBase.AbstractNLPEvaluator}" href="#MathProgBase.isobjquadratic-Tuple{MathProgBase.AbstractNLPEvaluator}"><code>MathProgBase.isobjquadratic</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isobjquadratic(::AbstractNLPEvaluator)</code></pre><p><code>true</code> if the objective function is known to be quadratic (convex or nonconvex), <code>false</code> otherwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L204-L208">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.isconstrlinear-Tuple{MathProgBase.AbstractNLPEvaluator,Integer}" href="#MathProgBase.isconstrlinear-Tuple{MathProgBase.AbstractNLPEvaluator,Integer}"><code>MathProgBase.isconstrlinear</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isconstrlinear(::AbstractNLPEvaluator, i::Integer)</code></pre><p><code>true</code> if the <span>$i^{\text{th}}$</span> constraint is known to be linear, <code>false</code> otherwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L212-L216">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.obj_expr" href="#MathProgBase.obj_expr"><code>MathProgBase.obj_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">obj_expr(d::AbstractNLPEvaluator)</code></pre><p>Returns an expression graph for the objective function as a standard Julia <code>Expr</code> object. All sums and products are flattened out as simple <code>Expr(:+,...)</code> and <code>Expr(:*,...)</code> objects. The symbol <code>x</code> is used as a placeholder for the vector of decision variables. No other undefined symbols are permitted; coefficients are embedded as explicit values. For example, the expression <span>$x_1+\sin(x_2/\exp(x_3))$</span> would be represented as the Julia object <code>:(x[1] + sin(x[2]/exp(x[3])))</code>. See the <a href="http://docs.julialang.org/en/release-0.3/manual/metaprogramming/#expressions-and-eval">Julia manual</a> for more information on the structure of <code>Expr</code> objects. There are currently no restrictions on recognized functions; typically these will be built-in Julia functions like <code>^</code>, <code>exp</code>, <code>log</code>, <code>cos</code>, <code>tan</code>, <code>sqrt</code>, etc., but modeling interfaces may choose to extend these basic functions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L163-L178">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.constr_expr" href="#MathProgBase.constr_expr"><code>MathProgBase.constr_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">constr_expr(d::AbstractNLPEvaluator, i)</code></pre><p>Returns an expression graph for the <span>$i^{\text{th}}$</span> constraint in the same format as described above. The head of the expression is <span>$:comparison$</span>, indicating the sense of the constraint. The right-hand side of the comparison must be a constant; that is, <code>:(x[1]^3 &lt;= 1)</code> is allowed, while <code>:(1 &lt;= x[1]^3)</code> is not valid. Double-sided constraints are allowed, in which case both the lower bound and upper bounds should be constants; for example, <code>:(-1 &lt;= cos(x[1]) + sin(x[2]) &lt;= 1)</code> is valid.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L182-L190">source</a><br/></section><h3><a class="nav-anchor" id="NLP-Attributes-1" href="#NLP-Attributes-1">NLP Attributes</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ConstraintNLPDual" href="#MathProgBase.ConstraintNLPDual"><code>MathProgBase.ConstraintNLPDual</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintNLPDual(N)
ConstraintNLPDual()</code></pre><p>The assignment to the NLP constraint dual values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L9-L14">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ConstraintNLPDualStart" href="#MathProgBase.ConstraintNLPDualStart"><code>MathProgBase.ConstraintNLPDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintNLPDualStart()</code></pre><p>An initial assignment of the NLP constriant duals that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/dfa8cd841952be72550f2804df25773e5b4da6f7/src/SolverInterface/nlp.jl#L21-L26">source</a><br/></section><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="highlevel.html"><span class="direction">Next</span><span class="title">High-level Interfaces</span></a></footer></article></body></html>
