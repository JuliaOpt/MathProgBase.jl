<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NLP · MathProgBase</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathProgBase</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="highlevel.html">High-level Interfaces</a></li><li><span class="toctext">Solver Interface</span><ul><li><a class="toctext" href="basics.html">Basics</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="objectives.html">Objectives</a></li><li><a class="toctext" href="constraints.html">Constraints</a></li><li><a class="toctext" href="sets.html">Sets</a></li><li><a class="toctext" href="attributes.html">Attributes</a></li><li><a class="toctext" href="statuscodes.html">Status Codes</a></li><li><a class="toctext" href="duals.html">Duals</a></li><li class="current"><a class="toctext" href="nlp.html">NLP</a><ul class="internal"><li><a class="toctext" href="#NLP-Methods-1">NLP Methods</a></li><li><a class="toctext" href="#NLP-Attributes-1">NLP Attributes</a></li></ul></li></ul></li><li><a class="toctext" href="choosingsolver.html">Choosing Solver</a></li></ul></nav><article id="docs"><header><nav><ul><li>Solver Interface</li><li><a href="nlp.html">NLP</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/docs/src/nlp.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>NLP</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="NonLinear-Programming-Interface-(NLP)-1" href="#NonLinear-Programming-Interface-(NLP)-1">NonLinear Programming Interface (NLP)</a></h1><h2><a class="nav-anchor" id="NLP-Methods-1" href="#NLP-Methods-1">NLP Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.loadnlp!" href="#MathProgBase.loadnlp!"><code>MathProgBase.loadnlp!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loadnlp!(m::AbstractNonlinearModel, numVar, numConstr, l, u, lb, ub, sense::OptimizationSense, d::AbstractNLPEvaluator)</code></pre><p>Loads the nonlinear programming problem into the model. The parameter <code>numVar</code> is the number of variables in the problem, <code>numConstr</code> is the number of constraints, <code>l</code> contains the variable lower bounds, <code>u</code> contains the variable upper bounds, <code>lb</code> contains the constraint lower bounds, and <code>ub</code> contains the constraint upper bounds. Sense contains the symbol <code>:Max</code> or <code>:Min</code>, indicating the direction of optimization. The final parameter <code>d</code> is an instance of an <code>AbstractNLPEvaluator</code>, described below, which may be queried for evaluating <span>$f$</span> and <span>$g$</span> and their corresponding derivatives.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L38-L42">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.initialize" href="#MathProgBase.initialize"><code>MathProgBase.initialize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">initialize(d::AbstractNLPEvaluator, requested_features::Vector{Symbol})</code></pre><p>Must be called before any other methods. The vector <code>requested_features</code> lists features requested by the solver. These may include <code>:Grad</code> for gradients of <span>$f$</span>, <code>:Jac</code> for explicit Jacobians of <span>$g$</span>, <code>:JacVec</code> for Jacobian-vector products, <code>:HessVe</code> for Hessian-vector and Hessian-of-Lagrangian-vector products, <code>:Hess</code> for explicit Hessians and Hessian-of-Lagrangians, and <code>:ExprGraph</code> for expression graphs.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L46-L55">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.features_available" href="#MathProgBase.features_available"><code>MathProgBase.features_available</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">features_available(d::AbstractNLPEvaluator)</code></pre><p>Returns the subset of features available for this problem instance, as a list of symbols in the same format as in <code>initialize</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L59-L64">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_f" href="#MathProgBase.eval_f"><code>MathProgBase.eval_f</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_f(d::AbstractNLPEvaluator, x)</code></pre><p>Evaluate <span>$f(x)$</span>, returning a scalar value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L68-L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_grad_f" href="#MathProgBase.eval_grad_f"><code>MathProgBase.eval_grad_f</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_grad_f(d::AbstractNLPEvaluator, g, x)</code></pre><p>Evaluate <span>$\nabla f(x)$</span> as a dense vector, storing  the result in the vector <code>g</code> which must be of the appropriate size.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L85-L90">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.jac_structure" href="#MathProgBase.jac_structure"><code>MathProgBase.jac_structure</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">jac_structure(d::AbstractNLPEvaluator)</code></pre><p>Returns the sparsity structure of the Jacobian matrix, <span>$J_g(x) = \left[ \begin{array}{c} \nabla g_1(x) \\ \nabla g_2(x) \\ \vdots \\ \nabla g_m(x) \end{array} \right]$</span> where <span>$g_i$</span> is the <span>$i\text{th}$</span> component of <span>$g$</span>. The sparsity structure is assumed to be independent of the point <span>$x$</span>. Returns a tuple <span>$(I,J)$</span> where <span>$I$</span> contains the row indices and <span>$J$</span> contains the column indices of each structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L94-L98">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.hesslag_structure" href="#MathProgBase.hesslag_structure"><code>MathProgBase.hesslag_structure</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hesslag_structure(d::AbstractNLPEvaluator)</code></pre><p>Returns the sparsity structure of the Hessian-of-the-Lagrangian matrix  <span>$\nabla^2 f + \sum_{i=1}^m \nabla^2 g_i$</span> as a tuple <span>$(I,J)$</span> where <span>$I$</span> contains the row indices and <span>$J$</span> contains the column indices of each structurally nonzero element. These indices are not required to be sorted and can contain duplicates, in which case the solver should combine the corresponding elements by adding them together. Any mix of lower and upper-triangular indices is valid. Elements <span>$(i,j)$</span> and <span>$(j,i)$</span>, if both present, should be treated as duplicates.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L102-L110">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_jac_g" href="#MathProgBase.eval_jac_g"><code>MathProgBase.eval_jac_g</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_jac_g(d::AbstractNLPEvaluator, J, x)</code></pre><p>Evaluates the sparse Jacobian matrix <span>$J_g(x) = \left[ \begin{array}{c} \nabla g_1(x) \\ \nabla g_2(x) \\ \vdots \\ \nabla g_m(x) \end{array} \right]$</span>. The result is stored in the vector <code>J</code> in the same order as the indices returned by <code>jac_structure</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L114-L120">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_jac_prod" href="#MathProgBase.eval_jac_prod"><code>MathProgBase.eval_jac_prod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_jac_prod(d::AbstractNLPEvaluator, y, x, w)</code></pre><p>Computes the Jacobian-vector product <span>$J_g(x)w$</span>, storing the result in the vector <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L124-L128">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_jac_prod_t" href="#MathProgBase.eval_jac_prod_t"><code>MathProgBase.eval_jac_prod_t</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_jac_prod_t(d::AbstractNLPEvaluator, y, x, w)</code></pre><p>Computes the Jacobian-transpose-vector product <span>$J_g(x)^T w$</span>, storing the result in the vector <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L132-L138">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_hesslag_prod" href="#MathProgBase.eval_hesslag_prod"><code>MathProgBase.eval_hesslag_prod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_hesslag_prod(d::AbstractNLPEvaluator, h, x, v, σ, μ)</code></pre><p>Given scalar weight <span>$σ$</span> and vector of constraint weights <span>$μ$</span>, computes the Hessian-of-the-Lagrangian-vector product <span>$\left( \sigma \nabla^2 f(x) + \sum_{i=1}^m \mu_i \nabla^2 g_i(x) \right)v$</span>,  storing the result in the vector <span>$h$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L142-L147">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.eval_hesslag" href="#MathProgBase.eval_hesslag"><code>MathProgBase.eval_hesslag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eval_hesslag(d::AbstractNLPEvaluator, H, x, σ, μ)</code></pre><p>Given scalar weight <code>σ</code> and vector of constraint weights <code>μ</code>,  computes the sparse Hessian-of-the-Lagrangian matrix  <span>$\sigma \nabla^2 f(x) + \sum_{i=1}^m \mu_i \nabla^2 g_i(x)$</span>,  storing the result in the vector <code>H</code> in the same order as the indices returned by <code>hesslag_structure</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L151-L159">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.isobjlinear-Tuple{MathProgBase.AbstractNLPEvaluator}" href="#MathProgBase.isobjlinear-Tuple{MathProgBase.AbstractNLPEvaluator}"><code>MathProgBase.isobjlinear</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isobjlinear(::AbstractNLPEvaluator)</code></pre><p><code>true</code> if the objective function is known to be linear, <code>false</code> otherwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L195-L200">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.isobjquadratic-Tuple{MathProgBase.AbstractNLPEvaluator}" href="#MathProgBase.isobjquadratic-Tuple{MathProgBase.AbstractNLPEvaluator}"><code>MathProgBase.isobjquadratic</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isobjquadratic(::AbstractNLPEvaluator)</code></pre><p><code>true</code> if the objective function is known to be quadratic (convex or nonconvex), <code>false</code> otherwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L204-L208">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.isconstrlinear-Tuple{MathProgBase.AbstractNLPEvaluator,Integer}" href="#MathProgBase.isconstrlinear-Tuple{MathProgBase.AbstractNLPEvaluator,Integer}"><code>MathProgBase.isconstrlinear</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isconstrlinear(::AbstractNLPEvaluator, i::Integer)</code></pre><p><code>true</code> if the <span>$i^{\text{th}}$</span> constraint is known to be linear, <code>false</code> otherwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L212-L216">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.obj_expr" href="#MathProgBase.obj_expr"><code>MathProgBase.obj_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">obj_expr(d::AbstractNLPEvaluator)</code></pre><p>Returns an expression graph for the objective function as a standard Julia <code>Expr</code> object. All sums and products are flattened out as simple <code>Expr(:+,...)</code> and <code>Expr(:*,...)</code> objects. The symbol <code>x</code> is used as a placeholder for the vector of decision variables. No other undefined symbols are permitted; coefficients are embedded as explicit values. For example, the expression <span>$x_1+\sin(x_2/\exp(x_3))$</span> would be represented as the Julia object <code>:(x[1] + sin(x[2]/exp(x[3])))</code>. See the <a href="http://docs.julialang.org/en/release-0.3/manual/metaprogramming/#expressions-and-eval">Julia manual</a> for more information on the structure of <code>Expr</code> objects. There are currently no restrictions on recognized functions; typically these will be built-in Julia functions like <code>^</code>, <code>exp</code>, <code>log</code>, <code>cos</code>, <code>tan</code>, <code>sqrt</code>, etc., but modeling interfaces may choose to extend these basic functions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L163-L178">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.constr_expr" href="#MathProgBase.constr_expr"><code>MathProgBase.constr_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">constr_expr(d::AbstractNLPEvaluator, i)</code></pre><p>Returns an expression graph for the <span>$i^{\text{th}}$</span> constraint in the same format as described above. The head of the expression is <span>$:comparison$</span>, indicating the sense of the constraint. The right-hand side of the comparison must be a constant; that is, <code>:(x[1]^3 &lt;= 1)</code> is allowed, while <code>:(1 &lt;= x[1]^3)</code> is not valid. Double-sided constraints are allowed, in which case both the lower bound and upper bounds should be constants; for example, <code>:(-1 &lt;= cos(x[1]) + sin(x[2]) &lt;= 1)</code> is valid.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L182-L190">source</a><br/></section><h2><a class="nav-anchor" id="NLP-Attributes-1" href="#NLP-Attributes-1">NLP Attributes</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ConstraintNLPDual" href="#MathProgBase.ConstraintNLPDual"><code>MathProgBase.ConstraintNLPDual</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintNLPDual(N)
ConstraintNLPDual()</code></pre><p>The assignment to the NLP constraint dual values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L9-L14">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathProgBase.ConstraintNLPDualStart" href="#MathProgBase.ConstraintNLPDualStart"><code>MathProgBase.ConstraintNLPDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintNLPDualStart()</code></pre><p>An initial assignment of the NLP constriant duals that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathProgBase.jl/tree/95134740405a15acaa1ff7612b62e6e9a971759c/src/SolverInterface/nlp.jl#L21-L26">source</a><br/></section><footer><hr/><a class="previous" href="duals.html"><span class="direction">Previous</span><span class="title">Duals</span></a><a class="next" href="choosingsolver.html"><span class="direction">Next</span><span class="title">Choosing Solver</span></a></footer></article></body></html>
